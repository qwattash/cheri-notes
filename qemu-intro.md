# Demo introduction to CHERI-QEMU development

## Status update

 - Completed merge to 6.2
   - Awaiting review
   - Need to fix performance regression
 - Tracing infrastructure is there but will be updated
   - Need to write documentation for others to use (CHERI wiki?)

## Intro to CHERI development

This is already mentioned in the getting started guides, but worth repeating.
Most CHERI applications can be built using the `cheribuild` tool found in the
[repo](https://github.com/CTSRD-CHERI/cheribuild).

Also see cheribsd [getting started](https://www.cheribsd.org/)

When running, `cheribuild` will clone repositories and can build dependencies if required.
You can place the `cheribuild.py` tool in your PATH or use a bash `alias`, I do the latter.

Cheribuild cheatsheet
```
# List all available targets
cbuild --list-targets

# Do not `git pull` for updates
cbuild --skip-update <target>

# Clean build or re-run configuration step (e.g. ./configure in autotools)
cbuild --reconfigure --clean <target>

# Build LLVM for CHERIv9/RISC-V and the Morello LLVM respectively
# (at some point things will be merged)
cbuild llvm
cbuild morello-llvm

# Build QEMU
cbuild qemu
```

Note that `cheribuild` can be customised using a config file in ~/.config/cheribuild.json
for more advanced setups.

## Intro to QEMU codebase

 1. Source code organisation overview (not sure how familiar are people)
    - Discuss general QEMU architecture
      - TCG infrastructure
      	- TCG basics and execution loop
	- Translation blocks
	- Interrupt and io escapes
      - Life of an instruction
      	- the translation loop
      	- per-target translation, translation helpers
	    - TB linking
    - Memory hierarhcy
      - machine ram => MMU translation layer and cputlb => memory accessors
 2. Where does CHERI go in all of this?
    - Capability format and compression (target/cheri-common/cheri-compressed-cap)
      - Mention it is shared with other projects.
      - Very useful [tool](https://www.morello-project.org/capinfo) if you find yourself with a bunch of bits to decode.
        Sadly it is Morello-only.
    - Common CHERI helpers (target/cheri-common)
    - Tag memory
    - Extensions to targets
      - target/riscv
      - target/arm
        - Relevant files
          - cheri.decode -- contains bit patterns for instruction decoding.
            These files are parsed by the `scripts/decodetree.py` tool and documented in `docs/devel/decodetree.rst`
          - translate-cheri.c.inc -- contains actual CHERI instruction TCG translations.
            Transforms a single instruction into TCG ops that will run on the host.
          - cpu.h -- General CPU state description and utility functions.
          - helper.c -- General CPU helpers (e.g. `arm_cpu_do_interrupt()`)


## Life of an Instruction

As an approachable way to introduce to QEMU, I want to show the CHERI implementation focusing on a single (simple) instruction.

We are at point in which QEMU finds a new instruction stream that needs to be translated.
We are in the TCG translation loop, at the beginning of a TB.
The translation loop will repeatedly invoke the target-specific translation hooks to decode instructions end emit TCG.

Condisder a `scbnds` instruction:
```
# From llvm-objdump -d path/to/kernel.full
ffff0000000020a4: ef 01 ce c2   scbnds  c15, c15, x14
```

Note that the disas above corresponds to:
```
31                  15                0
c    2    c    e    0    1    e    f
1100 0010 1100 1110 0000 0001 1110 1111
```

See `aarch64_tr_translate_insn()` in `target/arm/translate-a64.c`
```
    // disas_a64_insn()
    // Load the opcode from host memory
    uint32_t insn = arm_ldl_code(env, s->base.pc_next, s->sctlr_b);

    // Switch on bits [28:25] of the instruction
    switch (extract32(insn, 25, 4)) {
    ...
    case 0x1: /* Morello Instructions */
#ifdef TARGET_CHERI
        // Calls cheri-specific translation entrypoint generated by decodetree (cheri.decode)
        if (!disas_cheri(s, insn)) {
            unallocated_encoding(s);
        }
        break;
#endif
    ...
    }
```

The generated decoder will match the setbounds instruction.
```
// Note that there are two scbnds bit patterns, the first one is for the immediate variant
@op_SCBNDS    ........... imm6:6  S:1 .... Cn:5  Cd:5
@op_SC    ........... Rm:5 . opc:2 ... Cn:5  Cd:5

// We will match the second pattern specified as
SC 11000010110.....0..000.......... @op_SC

pattern: 11000010110.....0..000..........
instr:   11000010110011100000000111101111
```

As a result we will call the translation function for SC.
See `TRANS_F(SC)` in `target/arm/translate-cheri.c.inc`
```
// The translation functions are passed an arguments structure determined by the decodetree @op_xxx specification

    // in the function we check whether the SC-type instruction is a setbounds and generate TCG code accordingly.
    if (!(a->opc & 2)) {
        ...
        helper = &gen_helper_csetbounds;
        ...
        return gen_cheri_cap_cap_int(ctx, a->Cd, a->Cn, a->Rm, helper);
    }

```

The `gen_helper_csetbounds` will insert a sequence of instructions that will call the corresponding C
function to handle the execution of the instruction.
See `csetbounds` helper in `target/cheri-common/op_helper_cheri_common.c`, note that these functions use macros for declarations.
```
void CHERI_HELPER_IMPL(csetbounds(CPUArchState *env, uint32_t cd, uint32_t cb,
                                  target_ulong rt))
{
    // call into generic implementation, which will not get into
    do_setbounds(false, env, cd, cb, rt, GETPC());
}
```

Once the translation loop finds a function that signals the end of the TB (e.g. a branch), the TB is executed by jumping into it.
